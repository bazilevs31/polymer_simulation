
from itertools import izip

import numpy as np
from MDAnalysis import *
from MDAnalysis.core.distances import * ##distance_array
from MDAnalysis.core import flags #flags

# u=Universe("poly300.psf", "poly300.pdb")
u=Universe("../data/poly_40.psf", "../data/traj_40.dcd")

flags['use_periodic_selections'] = True
flags['use_KDTree_routines'] = False



def get_qab(coor):
# """gets uses coor of all bonds generated by get_bondlist_coords 
# returns qab tensor averaged for all atoms in the current frame"""
    nq = coor.shape[0]
    # print "nq = ", nq
    out = np.empty((3, 3),dtype=float32)
    dij = np.eye(3,dtype=float32)
    out = np.einsum('ij,ik->jk', coor, coor)
    return 1.5*out / float(nq) - 0.5*dij


def get_bondlist_coords(u):
# """get universe , return bonds(coordinates)
# 
# generate coor of all bonds(bond = chord i-1 - i+1 ), normalize it"""
    angles = u.angles
    bonds = angles.atom3.positions - angles.atom1.positions 
    # coords = angles.atom2.positions
    norm = np.linalg.norm(bonds,axis=1)
    bonds /= norm[:, None] #the norm vector is a (nx1) and we have to create dummy directions -> (n,3)
    return bonds

def get_bfactor(u, Nsub=7):

    box = u.trajectory.ts.dimensions[:-3]
    length_z = box[-1]
    length_y = box[-2]
    length_x = box[-3]
    arr_x=np.linspace(0.0,length_x,Nsub+1,endpoint=True)
    arr_y=np.linspace(0.0,length_y,Nsub+1,endpoint=True)
    arr_z=np.linspace(0.0,length_z,Nsub+1,endpoint=True)
    delta_x=arr_x[1]-arr_x[0]
    delta_y=arr_y[1]-arr_y[0]
    delta_z=arr_z[1]-arr_z[0]
    # dots_x=arr_x[1:-1]
    # dots_y=arr_y[1:-1]
    # dots_z=arr_z[1:-1]
    dots_x=arr_x
    dots_y=arr_y
    dots_z=arr_z

    atomselection=[]

    count=0


    for z in dots_z[0:-1]:
        ar_z = u.selectAtoms("prop  z >= " + str(z) + "  and  prop z < " + str(z+delta_z) )
        #ar_z is a planar selection
        # print "prop  z >= " + str(z) + "  and  prop z <= " + str(z+delta_z)
        print " z = ", z
        for y in dots_y[0:-1]:
            #ater this step ar_y is a line
            ar_y = ar_z.selectAtoms("prop  y >= " + str(y) + "  and  prop y < " + str(y+delta_y) )
            # print " y = ", y
            for x in dots_x[0:-1]:
                #ater this step ar_x is a dot
                print "i am here", count
                ar_x = ar_y.selectAtoms("prop  x >= " + str(x) + "  and  prop x < " + str(x+delta_x) )
                print ar_x.atoms
                qab=get_qab(get_bondlist_coords(ar_x))
                s=np.sqrt(1.5*np.trace(qab*qab))
                ar_x.set_bfactor(s)
                atomselection.append(ar_x)
                count+=1
                # print count
                # print " x = ", x

#get indices of atoms and then assign the bffactor just for the index of the atom
#in this case there is no need to assemble the parts into one big atomselection res
# to do that just get the indices of atoms in ar_x
# then just loop for atoms in u and assign bfactor of this atoms


# at5=atomselection[5]
# at5.set_bfactor(0.5)


# res=atomselection[0]
# # print res.selectBonds(('1','1'),)
# # res+=[i for i in atomselection[1:]]

# for i in xrange(1,len(atomselection)):
#     # print atomselection[i]
#     res+=atomselection[i]
# allatoms=u.selectAtoms("all")
# allatoms.write('poly60.pdb')
# # allatom = u.sele

