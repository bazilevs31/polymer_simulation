
# Program: bond_order.py
# Purpose: get the P2(cos\theta) parameter using Python
# Author:  Triandafilidi Vasiliy , MSc student at CHBE UBC, Vancouver
# e-mail:  vtriandafilidi(at)chbe(dot)ubc(dot)ca
# Syntax:  python bond_order.py
# Requires: polymer.psf, trajectory.xtc
# Status: Looks right, need testing on some real cases


# Theory:
#Order parameter P2 - is a way of measuring alignment of polymers along certain matrix
# P2 =def= 3/2<cos^2 \theta -1>, where averaging is performed over all atoms
# \theta =def=  angle(z_axis_of alignment, b_i)
# b_i =def= r_i - r_{i-2} - mean arithmetic of two bond vectors
# C1===C2===C3, i.e vec{C3 - C1}
# z_axis_of_alignment vector that corresponds to highest eigenvalue of tensor Qab
# Qab = 3/2 <<b_i**b_i>a - 1/3>f where averaging is performed over all atoms
# In our case we average Qab over last 400 frames where structure is crystalline
# The parameter P2 is : -1/2 < P2 < 1,
#P2 = 1 - perfect alignment, P2 = 0 amorphous, P2 = -1/2 is perpendicular to the z_axis 

# Copyright (c) 2014 Vasiliy Triandafilidi
# Released under the GNU Public Licence, v2 or any higher version 

from MDAnalysis import *
import numpy as np
from numbapro  import jit,autojit
# from numpy import linalg  as LA
from pylab import *


def get_bondlist_coords(u):
# """generate coor of all bonds(bond = chord i-1 - i+1 ), normalize it"""
    angles = u.angles
    bonds = angles.atom3.positions - angles.atom1.positions 
    # coords = angles.atom2.positions
    norm = np.linalg.norm(bonds,axis=1)
    bonds /= norm[:, None] #the norm vector is a (nx1) and we have to create dummy directions -> (n,3)
    return bonds

def get_qab(coor):
# """gets uses coor of all bonds generated by get_bondlist_coords 
# returns qab tensor averaged for all atoms in the current frame"""
    nq = coor.shape[0]
    # print "nq = ", nq
    out = np.empty((3, 3),dtype=float32)
    dij = np.eye(3,dtype=float32)
    out = np.einsum('ij,ik->jk', coor, coor)
    return 1.5*out / float(nq) - 0.5*dij

def get_eigen_vector(u, nsample):
# """return eigenvalue,eigen_vector 
# loop over all final stages of the trajectory, average the qab tensor, 
# find its eigen_vector corresponding to the largest eigenvalue """

    print "getting the eigen_values and eigen_vectors"
    Qab = np.zeros((3, 3),dtype=float32)
    nframes = len(u.trajectory)
    frame_start = nframes - nsample
    frame_finish = nframes
    for ts in u.trajectory[frame_start:frame_finish]:
        # print "frame is = ", ts.frame
        Qab += get_qab(get_bondlist_coords(u))
    Qab /= float(frame_finish - frame_start)
    print 
    # print np.trace(Qab)
    print "the Qab = " 
    print  Qab
    vals, vecs = np.linalg.eig(Qab)
    print " eigen vectors" 
    print vals[0], vecs[:, 0]
    return vecs[:, 0]

@jit('float32(float32[:,:], float32[:])')
def get_p2(coor, principal_vector):
    nq = coor.shape[0]
    p2 = 0.
    tmpvar = 0.0
    for i in xrange(0, nq):
        tmpvar = np.dot(coor[i], principal_vector)
        p2 += (3.0*tmpvar*tmpvar - 1.0)/2.0
    p2 /= float(nq)
    return p2


def get_order_param(u):
    """this function gets the universe
    uses the get_eigen_vector(universe) to get the eigen_vector
    then uses the get_bond_list(bondlist) to get the vectorized coor
    then uses the get_p2(coor, principal_vector) to get the p2"""
    print "running the get_order_param"
    principal_vector = get_eigen_vector(u,10)
    # print "the principal vector is = ", principal_vector
    Order_array = np.zeros((len(u.trajectory), 2))
    for ts in u.trajectory[1:-1]:
        order = get_p2(get_bondlist_coords(u), principal_vector)
        # Order_array.append((ts.frame, order))
        Order_array[ts.frame, 0] = ts.frame
        Order_array[ts.frame, 1] = order
        print "frame is = ", ts.frame, "order = ", order
    return Order_array

# u = Universe("../data/poly_40.psf", "../data/traj_40.dcd")
u = Universe("../coor_files/poly.psf", "../coor_files/traj_skip10.dcd")

# coords = np.random.rand(1000,3)
# norm = np.linalg.norm(coords,axis=1)
# coords /= norm[:, None]
# get_qab(coords)

get_order_param(u)